## Rxjava 解析
### Base classes 
* **Observable**   	0..N flows, no backpressure,
* **Flowable**  		0..N flows, supporting Reactive-Streams and backpressure
* **Single** 		a flow of exactly 1 item or an error
* **Completable** 	a flow without items but only a completion or error signal
* **Maybe** 		a flow with no items, exactly one item or an error.


### 相关概念（terminology）
* **upstream，downstream**
数据的流式操作，针对当前操作前面为upstream，后续为downstream
* **Objects in motion**
在RXJava的文档中，emission, emits, item, event, signal, data and message 被认为是同义词，并代表沿着数据流行进的对象。
* **Backpressure**
当数据流通过异步运行时，每个步骤可以以不同的速度执行不同的操作。为了避免压倒性的这些步骤，这些步骤通常表现为由于临时缓冲或需要跳过/删除数据而增加的内存使用量，应用所谓的背压，这是一种流量控制的形式，其中这些步骤可以表示它们准备处理多少个项目。这允许在数据流的内存使用限制的情况下，通常没有方法知道上游将发送多少项
在RxJava，专用的Flowable类被指定为支持背压，并且Observable专用于不支持背压（短序列、GUI交互等）。 Single, Maybe 和 Completable不支也持不应该背压，他们总是有空间暂时存储一个项目。
* **Assembly time 组装阶段**
通过应用各种中间运算符制备数据流发生在所谓的组装时间
* **Subscription time 订阅阶段**
当在内部建立一系列处理步骤的流程上调用subscribe()时，这是一个临时状态：
* **Runtime 运行阶段**
这是当流主动发射项目、错误或完成信号时的状态：

### Schedulers
RxJava操作符不直接使用线程或ExtutoServices，而是用所谓的调度器抽象出统一API背后的并发源。RXJava 2具有几个通过Schedulers工具类访问的标准调度器。

API 	| 使用场合
-------|-----------
Schedulers.computation() | 在后台固定数量的专用线程上运行计算密集型工作。大多数异步运算符将此作为默认Scheduler。
Schedulers.io() | 在动态改变的线程集上运行I/O类或阻塞操作。
Schedulers.single() | 以顺序和FIFO方式在单个线程上运行工作。
Schedulers.trampoline() | 在一个参与线程中以顺序和FIFO方式运行工作，通常用于测试目的。
### 实现原理
1. 组装阶段
    Observable ---optionc--- Observable 通过操作创建新的Observable并将上一个Observable作为 source
2. 订阅阶段
   最后的Observable 调用 subscribe（Observer）--> 实际调用 subscribeActual 创建新的Observer传入(原Observer作为downStream) 由source.subscribe(Observer)
3. 执行阶段
   源头开始执行，触发观察者。

## EventBus 解析

### 使用
1. 定义事件类。

	```
	public static class MessageEvent { /* Additional fields if needed */ }
	```
2. 实现订阅的方法，并在相应的类注册在EventBus

	```
	@Subscribe(threadMode = ThreadMode.MAIN)  
	public void onMessageEvent(MessageEvent event) {/* Do something */};
	
	
	 @Override
	 public void onStart() {
	     super.onStart();
	     EventBus.getDefault().register(this);
	 }
	
	 @Override
	 public void onStop() {
	     super.onStop();
	     EventBus.getDefault().unregister(this);
	 }
	``` 
3. 发送消息

	```
	EventBus.getDefault().post(new MessageEvent());
	```

### 源码分析

1. 订阅者的注册     

	EventBus.getDefault().register(this);
	通过反射的方法找到被@Subscribe标柱的方法，缓存下次注册直接去缓存。将Subscription(subscriber, subscriberMethod)按订阅事件的类型进行存储，按优先级排序。
	将订阅事件类型按订阅对象分类存储
	对于sticky订阅方法
	
## OkHttp 解析
### 使用





## Retrofit 解析

### 使用
1. 定义Service接口，对Api接口方法进行注解标注：

```
	 public interface Api {
	    @GET("users/{user}/repos")
	    Call<List<String>> listRepos(@Path("user") String user);
	}
```
2.使用Builder模式构建Retrofit实例：

```
	Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.github.com/")
                .build();
```
  
3.使用retrofit实例的create方法，创建代理对象，然后就可以通过代理对象发起网络请求：

```
    Api service = retrofit.create(Api.class);
    service.listRepos("octocat");
```

### 源码分析
####1. Retrofit对象的创建。
使用建造者模式，

* 可以添加client作为发起网络访问的客户端。
* addCallAdapterFactory 可以和RxJava等连用
* callbackExecutor 配置线程池全局统一管理调度线程
* addConverterFactory 对结果进行转换

####2. 代理对象的创建
retrofit.create方法使用动态代理的方式创建service，其中method便是我们接口定义的方法

	public <T> T create(final Class<T> service) {
	    validateServiceInterface(service);
	    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
	        new InvocationHandler() {
	          private final Platform platform = Platform.get();
	          private final Object[] emptyArgs = new Object[0];
	          @Override public @Nullable Object invoke(Object proxy, Method method,
	              @Nullable Object[] args) throws Throwable {
	            // If the method is a method from Object then defer to normal invocation.
	          ...
	            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
	          }
	        });
	  }

ServiceMethod对象的获取 

1. retrofit.loadServiceMethod(method) 
2. ServiceMethod.parseAnnotations(retrofit, method) // ServiceMethod 抽象类HttpServiceMethod为子类
3. requestFactory = RequestFactory.parseAnnotations(retrofit, method) // 获取请求的工厂对象
3. HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)
	* 	1. 传建callFactory = retrofit.callFactory 
	* 	2. 创建responseConverter = createResponseConverter(retrofit, method, responseType)
			*  retrofit.callAdapter(returnType, annotations)
	* 	3. 创建callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);
	* 	4. CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter)

	Object (java.lang) 
		ServiceMethod (retrofit2) A
			HttpServiceMethod (retrofit2) A
				CallAdapted in HttpServiceMethod (retrofit2) 
				SuspendForResponse in HttpServiceMethod (retrofit2)
				SuspendForBody in HttpServiceMethod (retrofit2)


ServiceMethod.invok();
	
	# HttpServiceMethod
	invok (Object[] args) {
		Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
		return adapt(call, args);
	}
	
	# CallAdapted
	@Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {
   		 return callAdapter.adapt(call);
    }
	

####3. 从中学到什么？
对于复杂的对象创建使用builder模式，

1. 实例化过程的有序性，保证对象构建过程安全。
2. 对象默认值，降低了使用难度，
3. 第三可配。置性是对象的构建更灵活。

使用动态代理来模式来实现代码隔离，接口定义对外调用的方法，通过动态代理实现具体功能，外部调用时看不到实现过程，起到了很好的隔离作用。

面向接口编程，增强了拓展性，降低了模块之间的耦合性。

对于有可能频繁去创建的对象，缓存池化管理，降低内存CPU的开销。

##热修复
资源替换 
1.通过反射创建新的AssertManager，通过反射调用addAssertPath 将我们新的资源的路径添加。
2.通过反射替换Resource的mAssert字段将引用指向1创建的AssertManager对象
类加载
    android 加载类时会从DexPathList的成员dexElements中逐个查找，每一个Element内部都封装了DexFile DexFile用来加载dex，所以我们通过反射将补丁dex
    插入到封装成Element插入到dexElements列表第一个元素，重新启动后优先会被加载，从而起到修复的作用，还有就是替换element，这就要求分dex时 哪个类在哪个dex中都是确定的。
底层替换方案：限制多 只能修改替换不能增删
instant Run

动态链接库的修复：
    so加载的方法 load 加载完整路径的so  loadLibrary 按so名称加载安装后解压路径下的so loadLibrary最终会调findLibrary方法。
    1.将so补丁插入到DexPathList的成员 nativeLibraryElement数组中让补丁so优先加载返回 ，和类的加载一样so也不会重复加载。
    2.使用系统的load方法接管so的加载，通过反射将补丁so路径作为参数。
##插件化 

hook的点一般为静态变量和单例对象，稳定不易变
加载
1.类加载  通过android的类加载机制 通过反射将需要加载的类的路径
2..so的加载
3.资源加载
4.组件的启动 
Activity 
hook IActivityManager 通过反射用代理对象替换系统的IActivityManager，从而将启动占坑Activity的intent替换为 目标Activity的intent
然后再hool ActivityThread 成员 mCallBack 在activity启动完成后将 将intent还原一边维持生命周期的正常运作。
hook Instrumentation 
Service
BroadCastReceiver
ContentProvider
